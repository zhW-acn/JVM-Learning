## 程序计数器PCR

线程私有。存放下一个字节码指令的地址，因为不存在申请内存所以不存在oom

## 虚拟机栈

线程私有。虚拟机栈中以栈帧为一个存储单元。栈帧中存储当前方法的操作数栈、局部变量表、帧数据。一个栈帧相当于一个方法，方法的调用相当于栈帧入栈，方法的返回或抛异常相当于栈帧出栈。

### 局部变量表

存储方法参数、方法内的局部变量、this指针。编译成字节码文件就可以确定局部变量表的内容。字节码里的LocalVariableTable保存的就是局部变量。

```java
public class A {
    public static void a() {
        int i = 0;
        long j = 0;
    }
}
```

对应字节码：

```
0 iconst_0
1 istore_0
2 iconst_1
3 istore_1
4 return
```

| Nr. | 起始PC | 长度 | 序号 | 名字 |
|-----|------|----|----|----|
| 0   | 2    | 3  | 0  | i  |
| 1   | 4    | 1  | 1  | j  |

Nr.：变量编号；起始PC：该变量在字节码里哪一行可以访问该变量；长度：可访问的范围；序号：该变量在槽数组【slot】里的索引

### slot

局部变量表槽

| i | j | j |
|---|---|---|
| 0 | 1 | 2 |

1. 用于存放栈帧中的this、参数、局部变量。32位以内的基本数据类型和引用数据类型占一个槽位，64位的long和double占两个槽位。实例方法比静态方法多存一个this指针。
2. 槽可被复用：某个局部变量出了其作用域，在其之后声明的变量会复用该槽位

### 操作数栈

用于存放字节码指令的中间数据，操作数栈最大深度即最多同时存在几个数。

### 帧数据

- 动态链接：当前类的字节码指令引用了其他类的属性或者方法时，需要将符号引用（编号）转换成对应的运行时常量池中的内存地址。动态链接就保存了编号到运行时常量池的内存地址的映射关系。
- 方法出口：是方法在正确或异常结束时，当前栈帧会被弹出。同时程序计数器应该指向下上一个栈帧中的下一条指令地址。所以在当前栈帧中，需要存储此方法出口地址
- 异常表：存放的是代码中异常的处理信息，包含了异常捕获的生效范围，以及异常发生后跳转到的字节码指令位置
- 使用-Xss设置栈大小。栈大小固定，栈帧数据与栈深度成反比

## 本地方法栈

在Hotspot虚拟机中，Java虚拟机栈和本地方法栈实现上使用了同一个栈空间。本地方法栈会在栈内存上生成一个栈帧，临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来

执行naive方法，也会抛出SOE和OOM

## 堆

存放对象的区域、字符串常量池。线程共享。

| used   | total  | max   |
|--------|--------|-------|
| 已使用堆内存 | 已分配堆内存 | 最大堆内存 |
|        | -Xms   | -Xmx  |

三个值相同不代表堆内存就溢出了。

设为相等的值【Xms=Xmx】减少申请内存分配的时间开销。且该值的一部分才是可分配对象的内存，而不是整个内存【JMX】。

## 方法区

方法区保存了字节码信息、运行时常量池、JIT编译后的代码缓存。

7版本的方法区在堆里【永久代】，8版本的方法区在直接内存里【元空间】。8版本使用-XX:MaxMetaspaceSize设置元空间大小。8版本因为方法区不在堆里，减少了FullGC次数

## 直接内存

传统IO要从用户态切为内核态，把磁盘文件读到系统缓存，再切换为用户态，由java从堆内存分配缓存区并从系统缓存读取。两次复制浪费时空间。使用NIO库的ByteBuffer类。将磁盘文件读到直接内存，在堆上直接引用，减少了复制的开销。


## 各种池
1. 常量池：处于字节码文件。用于存放编译器生成的字面量和符号引用
2. 运行时常量池：处于方法区中。当类加载到内存中后，各个字节码的常量池被放入运行时常量池中。符号引用也会替换成直接引用
3. 字符串常量池：类在准备阶段完成后，在堆中生成的字符串对象。然后将该对象的引用值存到字符串常量池中
